<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: api/controllers/authController.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: api/controllers/authController.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const {OAuth2Client} = require('google-auth-library');
const CLIENT_ID = '526092300621-j8ki44lp0fpnb5da2s3c3iqu33fde3tk.apps.googleusercontent.com';
const client = new OAuth2Client(CLIENT_ID);
const uuidv4 = require('uuid/v4');

const mongoose = require('mongoose');
const User = mongoose.model('user');
const Session = mongoose.model('session');
const roles = require('../../src/roles');
const util = require('./util');

// Set timeout 1 day from now
const timeout = 1*24*60*60*1000;

// test session, must only be used for testing
let testSession = null;

/**
 * @return {string} a secure session token
 */
function generateKey() {
  // https://gist.github.com/joepie91/7105003c3b26e65efcea63f3db82dfba
  // This is by far the most important part of our security strategy
  return uuidv4();
}

/**
* @description This function returns a promise
*    that returns the userId of this session
*    or it rejects if session is invalid
* @param {request} req is the request received
* @param {role} level is the role you must have inorder to be authenticated
* @return {promise} a promise that can be used for authentication
*/
exports.auth = function(req, level=roles.NONE) {
  return new Promise(function(resolve, reject) {
    const sessionId = req.cookies.sessionId;

    // If we are in a testing mode
    if (process.env.JEST_WORKER_ID !== undefined) {
      if (testSession === sessionId) {
        // This must ONLY RUN in testing
        resolve(testSession);
        return;
      }
    }

    if (sessionId == null || sessionId == undefined) {
      reject(Error('No sessionId provided'));
    }
    Session.findOne({sessionId: sessionId}, function(err, session) {
      if (err) {
        reject(err);
        return;
      }
      // No session exists
      if (!session) {
        reject(Error('No valid session exists'));
        return;
      }

      // Session has expired
      if (session.expiration_date &lt; Date.now()) {
        reject(Error('Your session has expired'));
        return;
      }

      User.findOne({userId: session.userId}, function(err, user) {
        if (err) reject(Error(err));

        // Make sure user exists
        if (!user) {
          reject(Error('No valid user exists'));
          return;
        }

        if (level === roles.NONE) {
          resolve(session.userId);
        } else {
          // Make sure user has valid permission
          if (user.permission === level) {
            resolve(user.userId);
          } else {
            reject(Error('Invalid permissions'));
          }
        }
      });
    });
  });
};

/**
* @description returns the current list of sessions
*   must be an admin to view
* @param {request} req is the request received
* @param {response} res is the response object
*/
exports.listSessions = function(req, res) {
  exports.auth(req, roles.ADMIN).then((userId)=>{
    util.getAllData(Session)(req, res);
  }).catch((err)=>res.status(401).send(err));
};

/**
* @description returns the info for a specific session
*   must be an admin to view
* @param {request} req is the request received
* @param {response} res is the response object
*/
exports.getSession = function(req, res) {
  exports.auth(req, roles.ADMIN).then((userId)=>{
    Session.findOne({sessionId: req.params.sessionId}, function(err, session) {
      if (err) res.send(err);
      res.json(session);
    });
  }).catch((err)=>res.status(401).send(err));
};

/**
* @description allows a new session to be created for a user
*   must use google to authenticate
* @param {request} req is the request received
* @param {response} res is the response object
*/
exports.login = function(req, res) {
  /**
  * @param {object} body of the request
  * @return {object} the verified payload from google
  */
  async function verify(body) {
    const ticket = await client.verifyIdToken({
      idToken: body.idtoken,
      audience: CLIENT_ID,
    });
    const payload = ticket.getPayload();
    return payload;
  }

  verify(req.body).then((payload)=>{
    const userId = payload['sub'];
    // If request specified a G Suite domain:
    // const domain = payload['hd'];

    User.findOne({userId: userId}, function(err, doc) {
      if (err) {
        res.status(500).send(null);
        return;
      }
      if (doc === null) {
        res.status(400).send('No valid user exists for: ' + String(userId));
        return;
      }

      const newSession = new Session({
        userId: doc.userId,
        sessionId: generateKey(),
        expiration_date: new Date(Date.now()+timeout),
      });

      newSession.save(function(err, session) {
        if (err) {
          res.send(err);
        } else {
          res.json(session);
        }
      });
    });
  }).catch((err)=>{
    res.status(500);
    res.send(String(err));
  });
};

/**
* @description stops and drops the current session of the user
* @param {request} req is the request received
* @param {response} res is the response object
*/
exports.logout = function(req, res) {
  Session.deleteOne({sessionId: req.cookies.sessionId}, function(err, task) {
    if (err) res.send(err);
    res.json({message: 'Sucessfully logged out'});
  });
};

/**
* @description allows an admin to invalidate a session
*   must be an admin to invalidate a session
* @param {request} req is the request received
* @param {response} res is the response object
*/
exports.invalidateSession = function(req, res) {
  exports.auth(req, roles.ADMIN).then(()=>{
    Session.deleteOne({sessionId: req.params.sessionId}, function(err, task) {
      if (err) res.send(err);
      res.json({message: 'Sucessfully dropped session'});
    });
  }).catch((err)=>res.status(401).send(String(err)));
};

/**
* @description drops all sessions in the database
* @param {function} callback is a callback to be run after finishing deleting
* @param {response} res is the response object
*/
exports.deleteAll = function(callback) {
  // We must be running in a test:
  if (process.env.JEST_WORKER_ID === undefined) {
    throw new Error('Must not run this function outside of tests');
  }
  Session.deleteMany({}, callback);
};


/**
* @description sets a test session for testing purposes
* @param {sessionId} sessionId to be used for testing
*/
exports.setTestSession = function(sessionId) {
  // We must be running in a test:
  if (process.env.JEST_WORKER_ID === undefined) {
    throw new Error('Must not run this function outside of tests');
  }
  testSession = sessionId;
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-app.html">app</a></li></ul><h3>Classes</h3><ul><li><a href="MongooseEnvironment.html">MongooseEnvironment</a></li></ul><h3>Global</h3><ul><li><a href="global.html#auth">auth</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createFeedback">createFeedback</a></li><li><a href="global.html#createTestEntrances">createTestEntrances</a></li><li><a href="global.html#createTestSections">createTestSections</a></li><li><a href="global.html#deleteAll">deleteAll</a></li><li><a href="global.html#deleteFeedback">deleteFeedback</a></li><li><a href="global.html#directions">directions</a></li><li><a href="global.html#generateKey">generateKey</a></li><li><a href="global.html#geocode">geocode</a></li><li><a href="global.html#getAll">getAll</a></li><li><a href="global.html#getById">getById</a></li><li><a href="global.html#getClosedEntrancePolygons">getClosedEntrancePolygons</a></li><li><a href="global.html#getSession">getSession</a></li><li><a href="global.html#invalidateSession">invalidateSession</a></li><li><a href="global.html#listFeedback">listFeedback</a></li><li><a href="global.html#listSessions">listSessions</a></li><li><a href="global.html#login">login</a></li><li><a href="global.html#logout">logout</a></li><li><a href="global.html#mapsurfer">mapsurfer</a></li><li><a href="global.html#pois">pois</a></li><li><a href="global.html#readFeedback">readFeedback</a></li><li><a href="global.html#readFeedbackByEntranceId">readFeedbackByEntranceId</a></li><li><a href="global.html#readFeedbackByType">readFeedbackByType</a></li><li><a href="global.html#setTestSession">setTestSession</a></li><li><a href="global.html#update">update</a></li><li><a href="global.html#updateFeedback">updateFeedback</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Apr 25 2019 15:10:13 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
